// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: ad.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAd = `-- name: CreateAd :one
INSERT INTO ad (publisher_ad_key, publisher_id, created_at, updated_at, published_at, category, author,
                url, title, description, city, neighborhood, house_type, meterage, rooms_count, year,
                floor, total_floors, has_warehouse, has_elevator, lat, lng)
VALUES ($1, $2, NOW(), NOW(), $3,
        $4, $5,
        $6, $7, $8, $9, $10,
        $11, $12, $13, $14,
        $15, $16, $17, $18,
        $19, $20)
RETURNING id, publisher_ad_key, publisher_id, created_at, updated_at, published_at, category, author, url, title, description, city, neighborhood, house_type, meterage, rooms_count, year, floor, total_floors, has_warehouse, has_elevator, lat, lng
`

type CreateAdParams struct {
	PublisherAdKey string
	PublisherID    pgtype.Int4
	PublishedAt    pgtype.Timestamp
	Category       NullAdCategory
	Author         pgtype.Text
	Url            pgtype.Text
	Title          pgtype.Text
	Description    pgtype.Text
	City           pgtype.Text
	Neighborhood   pgtype.Text
	HouseType      NullHouseType
	Meterage       pgtype.Int4
	RoomsCount     pgtype.Int4
	Year           pgtype.Int4
	Floor          pgtype.Int4
	TotalFloors    pgtype.Int4
	HasWarehouse   pgtype.Bool
	HasElevator    pgtype.Bool
	Lat            pgtype.Numeric
	Lng            pgtype.Numeric
}

// Insert a new ad
func (q *Queries) CreateAd(ctx context.Context, arg CreateAdParams) (Ad, error) {
	row := q.db.QueryRow(ctx, createAd,
		arg.PublisherAdKey,
		arg.PublisherID,
		arg.PublishedAt,
		arg.Category,
		arg.Author,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.City,
		arg.Neighborhood,
		arg.HouseType,
		arg.Meterage,
		arg.RoomsCount,
		arg.Year,
		arg.Floor,
		arg.TotalFloors,
		arg.HasWarehouse,
		arg.HasElevator,
		arg.Lat,
		arg.Lng,
	)
	var i Ad
	err := row.Scan(
		&i.ID,
		&i.PublisherAdKey,
		&i.PublisherID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.Category,
		&i.Author,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.City,
		&i.Neighborhood,
		&i.HouseType,
		&i.Meterage,
		&i.RoomsCount,
		&i.Year,
		&i.Floor,
		&i.TotalFloors,
		&i.HasWarehouse,
		&i.HasElevator,
		&i.Lat,
		&i.Lng,
	)
	return i, err
}

const deleteAd = `-- name: DeleteAd :exec
DELETE
FROM ad
WHERE publisher_ad_key = $1
`

// Delete an ad by publisher_ad_key
func (q *Queries) DeleteAd(ctx context.Context, publisherAdKey pgtype.Text) error {
	_, err := q.db.Exec(ctx, deleteAd, publisherAdKey)
	return err
}

const filterAds = `-- name: FilterAds :many
SELECT id, publisher_ad_key, publisher_id, created_at, updated_at, published_at, category, author, url, title, description, city, neighborhood, house_type, meterage, rooms_count, year, floor, total_floors, has_warehouse, has_elevator, lat, lng
FROM ad
WHERE (publisher_id = coalesce($1, publisher_id))
  AND (updated_at BETWEEN coalesce($2, updated_at) AND coalesce($3, updated_at))
  AND (published_at BETWEEN coalesce($4, published_at) AND coalesce($5, published_at))
  AND (category = coalesce($6, category))
  AND (author = coalesce($7, author))
  AND (city = coalesce($8, city))
  AND (neighborhood = coalesce($9, neighborhood))
  AND (house_type = coalesce($10, house_type))
  AND (meterage BETWEEN coalesce($11, meterage) AND coalesce($12, meterage))
  AND (rooms_count BETWEEN coalesce($13, rooms_count) AND coalesce($14, rooms_count))
  AND (year BETWEEN coalesce($15, year) AND coalesce($16, year))
  AND (floor BETWEEN coalesce($17, floor) AND coalesce($18, floor))
  AND (total_floors BETWEEN coalesce($19, total_floors) AND coalesce($20, total_floors))
  AND (has_warehouse = coalesce($21, has_warehouse))
  AND (has_elevator = coalesce($22, has_elevator))
  AND (lat BETWEEN coalesce($23, lat) AND coalesce($24, lat))
  AND (lng BETWEEN coalesce($25, lng) AND coalesce($26, lng))
ORDER BY created_at DESC
LIMIT $28 OFFSET $27
`

type FilterAdsParams struct {
	PublisherID    pgtype.Int4
	MinUpdatedAt   pgtype.Timestamp
	MaxUpdatedAt   pgtype.Timestamp
	MinPublishedAt pgtype.Timestamp
	MaxPublishedAt pgtype.Timestamp
	Category       NullAdCategory
	Author         pgtype.Text
	City           pgtype.Text
	Neighborhood   pgtype.Text
	HouseType      NullHouseType
	MinMeterage    pgtype.Int4
	MaxMeterage    pgtype.Int4
	MinRooms       pgtype.Int4
	MaxRooms       pgtype.Int4
	MinYear        pgtype.Int4
	MaxYear        pgtype.Int4
	MinFloor       pgtype.Int4
	MaxFloor       pgtype.Int4
	MinTotalFloors pgtype.Int4
	MaxTotalFloors pgtype.Int4
	HasWarehouse   pgtype.Bool
	HasElevator    pgtype.Bool
	MinLat         pgtype.Numeric
	MaxLat         pgtype.Numeric
	MinLng         pgtype.Numeric
	MaxLng         pgtype.Numeric
	Offset         pgtype.Int4
	Limit          pgtype.Int4
}

// Comprehensive ad search with all attribute filters, including ranges and additional fields
func (q *Queries) FilterAds(ctx context.Context, arg FilterAdsParams) ([]Ad, error) {
	rows, err := q.db.Query(ctx, filterAds,
		arg.PublisherID,
		arg.MinUpdatedAt,
		arg.MaxUpdatedAt,
		arg.MinPublishedAt,
		arg.MaxPublishedAt,
		arg.Category,
		arg.Author,
		arg.City,
		arg.Neighborhood,
		arg.HouseType,
		arg.MinMeterage,
		arg.MaxMeterage,
		arg.MinRooms,
		arg.MaxRooms,
		arg.MinYear,
		arg.MaxYear,
		arg.MinFloor,
		arg.MaxFloor,
		arg.MinTotalFloors,
		arg.MaxTotalFloors,
		arg.HasWarehouse,
		arg.HasElevator,
		arg.MinLat,
		arg.MaxLat,
		arg.MinLng,
		arg.MaxLng,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterAdsByIdsAndPriceRange = `-- name: FilterAdsByIdsAndPriceRange :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.lat, ad.lng
FROM ad
         JOIN (SELECT DISTINCT ON (ad_id) ad_id, total_price
               FROM price
               WHERE ad_id = ANY ($1::int[])
                 AND total_price BETWEEN $2 AND $3
               ORDER BY ad_id, fetched_at DESC) latest_price ON latest_price.ad_id = ad.id
ORDER BY ad.created_at DESC
`

type FilterAdsByIdsAndPriceRangeParams struct {
	AdIds    []int32
	MinPrice pgtype.Int8
	MaxPrice pgtype.Int8
}

// Filter ads based on list of IDs and price range
func (q *Queries) FilterAdsByIdsAndPriceRange(ctx context.Context, arg FilterAdsByIdsAndPriceRangeParams) ([]Ad, error) {
	rows, err := q.db.Query(ctx, filterAdsByIdsAndPriceRange, arg.AdIds, arg.MinPrice, arg.MaxPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterAdsByPriceRange = `-- name: FilterAdsByPriceRange :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.lat, ad.lng
FROM ad
         JOIN (SELECT DISTINCT ON (ad_id) ad_id, total_price
               FROM price
               WHERE (total_price BETWEEN $1 AND $2)
               ORDER BY ad_id, fetched_at DESC) latest_price ON latest_price.ad_id = ad.id
ORDER BY ad.created_at DESC
LIMIT $4 OFFSET $3
`

type FilterAdsByPriceRangeParams struct {
	MinPrice pgtype.Int8
	MaxPrice pgtype.Int8
	Offset   pgtype.Int4
	Limit    pgtype.Int4
}

// Get ads with their latest price within the specified range.
// This only includes ads where the latest price falls within the specified range.
// For each ad, it selects the most recent price (based on fetched_at) in the range.
func (q *Queries) FilterAdsByPriceRange(ctx context.Context, arg FilterAdsByPriceRangeParams) ([]Ad, error) {
	rows, err := q.db.Query(ctx, filterAdsByPriceRange,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdsByPublisher = `-- name: GetAdsByPublisher :many
SELECT id, publisher_ad_key, publisher_id, created_at, updated_at, published_at, category, author, url, title, description, city, neighborhood, house_type, meterage, rooms_count, year, floor, total_floors, has_warehouse, has_elevator, lat, lng
FROM ad
WHERE publisher_id = $1
ORDER BY created_at DESC
`

// Get ads by publisher ID
func (q *Queries) GetAdsByPublisher(ctx context.Context, publisherID pgtype.Int4) ([]Ad, error) {
	rows, err := q.db.Query(ctx, getAdsByPublisher, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdsPublisherByAdKey = `-- name: GetAdsPublisherByAdKey :one
SELECT ad.publisher_ad_key
FROM ad
WHERE ad.id = $1
`

// Get PublisherAdKey for one specific ad
func (q *Queries) GetAdsPublisherByAdKey(ctx context.Context, adKey pgtype.Int8) (string, error) {
	row := q.db.QueryRow(ctx, getAdsPublisherByAdKey, adKey)
	var publisher_ad_key string
	err := row.Scan(&publisher_ad_key)
	return publisher_ad_key, err
}

const getAdsWithoutPrice = `-- name: GetAdsWithoutPrice :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.lat, ad.lng
FROM ad
         LEFT JOIN price ON price.ad_id = ad.id
WHERE price.id IS NULL
`

// Get ads without associated price
func (q *Queries) GetAdsWithoutPrice(ctx context.Context) ([]Ad, error) {
	rows, err := q.db.Query(ctx, getAdsWithoutPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAds = `-- name: GetAllAds :many
SELECT id, publisher_ad_key, publisher_id, created_at, updated_at, published_at, category, author, url, title, description, city, neighborhood, house_type, meterage, rooms_count, year, floor, total_floors, has_warehouse, has_elevator, lat, lng
FROM ad
ORDER BY CASE
             WHEN $1 = 'published_at' THEN published_at
             WHEN $1 = 'updated_at' THEN updated_at
             WHEN $1 = 'created_at' THEN created_at
             WHEN $1 = 'year' THEN year
             ELSE id -- Default to ordering by id if no valid order_by is provided
             END
        DESC
LIMIT $3 OFFSET $2
`

type GetAllAdsParams struct {
	OrderBy interface{}
	Offset  pgtype.Int4
	Limit   pgtype.Int4
}

// Get all ads with dynamic ordering, limit, and offset
func (q *Queries) GetAllAds(ctx context.Context, arg GetAllAdsParams) ([]Ad, error) {
	rows, err := q.db.Query(ctx, getAllAds, arg.OrderBy, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAd = `-- name: UpdateAd :one
UPDATE ad
SET publisher_ad_key = COALESCE($1, publisher_ad_key),
    publisher_id     = COALESCE($2, publisher_id),
    updated_at       = NOW(),
    published_at     = COALESCE($3, published_at),
    category         = COALESCE($4, category),
    author           = COALESCE($5, author),
    url              = COALESCE($6, url),
    title            = COALESCE($7, title),
    description      = COALESCE($8, description),
    city             = COALESCE($9, city),
    neighborhood     = COALESCE($10, neighborhood),
    house_type       = COALESCE($11, house_type),
    meterage         = COALESCE($12, meterage),
    rooms_count      = COALESCE($13, rooms_count),
    year             = COALESCE($14, year),
    floor            = COALESCE($15, floor),
    total_floors     = COALESCE($16, total_floors),
    has_warehouse    = COALESCE($17, has_warehouse),
    has_elevator     = COALESCE($18, has_elevator),
    lat              = COALESCE($19, lat),
    lng              = COALESCE($20, lng)
WHERE publisher_ad_key = $1
RETURNING id, publisher_ad_key, publisher_id, created_at, updated_at, published_at, category, author, url, title, description, city, neighborhood, house_type, meterage, rooms_count, year, floor, total_floors, has_warehouse, has_elevator, lat, lng
`

type UpdateAdParams struct {
	PublisherAdKey pgtype.Text
	PublisherID    pgtype.Int4
	PublishedAt    pgtype.Timestamp
	Category       NullAdCategory
	Author         pgtype.Text
	Url            pgtype.Text
	Title          pgtype.Text
	Description    pgtype.Text
	City           pgtype.Text
	Neighborhood   pgtype.Text
	HouseType      NullHouseType
	Meterage       pgtype.Int4
	RoomsCount     pgtype.Int4
	Year           pgtype.Int4
	Floor          pgtype.Int4
	TotalFloors    pgtype.Int4
	HasWarehouse   pgtype.Bool
	HasElevator    pgtype.Bool
	Lat            pgtype.Numeric
	Lng            pgtype.Numeric
}

// Update an existing ad's details with optional fields
func (q *Queries) UpdateAd(ctx context.Context, arg UpdateAdParams) (Ad, error) {
	row := q.db.QueryRow(ctx, updateAd,
		arg.PublisherAdKey,
		arg.PublisherID,
		arg.PublishedAt,
		arg.Category,
		arg.Author,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.City,
		arg.Neighborhood,
		arg.HouseType,
		arg.Meterage,
		arg.RoomsCount,
		arg.Year,
		arg.Floor,
		arg.TotalFloors,
		arg.HasWarehouse,
		arg.HasElevator,
		arg.Lat,
		arg.Lng,
	)
	var i Ad
	err := row.Scan(
		&i.ID,
		&i.PublisherAdKey,
		&i.PublisherID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.Category,
		&i.Author,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.City,
		&i.Neighborhood,
		&i.HouseType,
		&i.Meterage,
		&i.RoomsCount,
		&i.Year,
		&i.Floor,
		&i.TotalFloors,
		&i.HasWarehouse,
		&i.HasElevator,
		&i.Lat,
		&i.Lng,
	)
	return i, err
}

const updateAdUpdatedAt = `-- name: UpdateAdUpdatedAt :exec
UPDATE ad
SET updated_at = NOW()
WHERE publisher_ad_key = $1
`

// Update ad updated_at timestamp by publisher_ad_key
func (q *Queries) UpdateAdUpdatedAt(ctx context.Context, publisherAdKey pgtype.Text) error {
	_, err := q.db.Exec(ctx, updateAdUpdatedAt, publisherAdKey)
	return err
}
