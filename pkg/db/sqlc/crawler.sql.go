// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: crawler.sql

package sqlc

import (
	"context"
)

const changeAllCrawlJobsStatus = `-- name: ChangeAllCrawlJobsStatus :exec
UPDATE crawl_jobs 
SET status = $1
WHERE status = ANY($2::text[])
`

type ChangeAllCrawlJobsStatusParams struct {
	NewStatus string   `json:"new_status"`
	Statuses  []string `json:"statuses"`
}

// new_status: text
// current_statuses: text[]
func (q *Queries) ChangeAllCrawlJobsStatus(ctx context.Context, arg ChangeAllCrawlJobsStatusParams) error {
	_, err := q.db.Exec(ctx, changeAllCrawlJobsStatus, arg.NewStatus, arg.Statuses)
	return err
}

const checkCrawlJobExists = `-- name: CheckCrawlJobExists :one
SELECT EXISTS (
    SELECT 1 FROM crawl_jobs 
    WHERE url = $1 AND status = ANY($2::text[])
) AS exists
`

type CheckCrawlJobExistsParams struct {
	Url      string   `json:"url"`
	Statuses []string `json:"statuses"`
}

// url: text
// statuses: text[]
func (q *Queries) CheckCrawlJobExists(ctx context.Context, arg CheckCrawlJobExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkCrawlJobExists, arg.Url, arg.Statuses)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCrawlJob = `-- name: CreateCrawlJob :one
INSERT INTO crawl_jobs (url, source_name, page_type, status)
VALUES ($1, $2, $3, $4)
RETURNING id, url, source_name, page_type, status, created_at, updated_at
`

type CreateCrawlJobParams struct {
	Url        string `json:"url"`
	SourceName string `json:"source_name"`
	PageType   string `json:"page_type"`
	Status     string `json:"status"`
}

// Insert a new crawl job
func (q *Queries) CreateCrawlJob(ctx context.Context, arg CreateCrawlJobParams) (CrawlJob, error) {
	row := q.db.QueryRow(ctx, createCrawlJob,
		arg.Url,
		arg.SourceName,
		arg.PageType,
		arg.Status,
	)
	var i CrawlJob
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.SourceName,
		&i.PageType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFirstCrawlJobByStatus = `-- name: GetFirstCrawlJobByStatus :one
SELECT id, url, source_name, page_type, status, created_at, updated_at FROM crawl_jobs
WHERE status = $1 
LIMIT 1
`

func (q *Queries) GetFirstCrawlJobByStatus(ctx context.Context, status string) (CrawlJob, error) {
	row := q.db.QueryRow(ctx, getFirstCrawlJobByStatus, status)
	var i CrawlJob
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.SourceName,
		&i.PageType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFirstMatchingCrawlJob = `-- name: GetFirstMatchingCrawlJob :one
SELECT id, url, source_name, page_type, status, created_at, updated_at FROM crawl_jobs
WHERE url = $1 AND status = ANY($2::text[])
LIMIT 1
`

type GetFirstMatchingCrawlJobParams struct {
	Url      string   `json:"url"`
	Statuses []string `json:"statuses"`
}

// url: text
// statuses: text[]
func (q *Queries) GetFirstMatchingCrawlJob(ctx context.Context, arg GetFirstMatchingCrawlJobParams) (CrawlJob, error) {
	row := q.db.QueryRow(ctx, getFirstMatchingCrawlJob, arg.Url, arg.Statuses)
	var i CrawlJob
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.SourceName,
		&i.PageType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCrawlJobStatus = `-- name: UpdateCrawlJobStatus :one
UPDATE crawl_jobs 
SET status = $1 
WHERE id = $2
RETURNING id
`

type UpdateCrawlJobStatusParams struct {
	Status string `json:"status"`
	JobID  int64  `json:"jobID"`
}

func (q *Queries) UpdateCrawlJobStatus(ctx context.Context, arg UpdateCrawlJobStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateCrawlJobStatus, arg.Status, arg.JobID)
	var id int64
	err := row.Scan(&id)
	return id, err
}
