// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: price.sql

package sqlc

import (
	"context"
)

const createPrice = `-- name: CreatePrice :one
INSERT INTO price (ad_id, fetched_at, has_price, total_price, price_per_meter, mortgage, normal_price, weekend_price)
VALUES ($1,
        NOW(),
        $2,
        $3,
        $4,
        $5,
        $6,
        $7)
RETURNING id, ad_id, fetched_at, has_price, total_price, price_per_meter, mortgage, normal_price, weekend_price
`

type CreatePriceParams struct {
	AdID          int64  `json:"ad_id"`
	HasPrice      *bool  `json:"has_price"`
	TotalPrice    *int64 `json:"total_price"`
	PricePerMeter *int64 `json:"price_per_meter"`
	Mortgage      *int64 `json:"mortgage"`
	NormalPrice   *int64 `json:"normal_price"`
	WeekendPrice  *int64 `json:"weekend_price"`
}

// Insert a new price entry for a specific ad
func (q *Queries) CreatePrice(ctx context.Context, arg CreatePriceParams) (Price, error) {
	row := q.db.QueryRow(ctx, createPrice,
		arg.AdID,
		arg.HasPrice,
		arg.TotalPrice,
		arg.PricePerMeter,
		arg.Mortgage,
		arg.NormalPrice,
		arg.WeekendPrice,
	)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.AdID,
		&i.FetchedAt,
		&i.HasPrice,
		&i.TotalPrice,
		&i.PricePerMeter,
		&i.Mortgage,
		&i.NormalPrice,
		&i.WeekendPrice,
	)
	return i, err
}

const filterAdsPriceBuy = `-- name: FilterAdsPriceBuy :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.has_parking, ad.lat, ad.lng
FROM ad
         JOIN (SELECT DISTINCT ON (ad_id) ad_id, total_price, price_per_meter
               FROM price
               WHERE ad_id = ANY ($1::bigint[])
                 AND total_price BETWEEN $2 AND $3
               ORDER BY ad_id, fetched_at DESC) latest_price ON latest_price.ad_id = ad.id
ORDER BY ad.created_at DESC
`

type FilterAdsPriceBuyParams struct {
	AdIds    []int64 `json:"ad_ids"`
	MinPrice *int64  `json:"min_price"`
	MaxPrice *int64  `json:"max_price"`
}

// Filter ads based on list of IDs and price range (buy category)
func (q *Queries) FilterAdsPriceBuy(ctx context.Context, arg FilterAdsPriceBuyParams) ([]Ad, error) {
	rows, err := q.db.Query(ctx, filterAdsPriceBuy, arg.AdIds, arg.MinPrice, arg.MaxPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.HasParking,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterAdsPriceMortgage = `-- name: FilterAdsPriceMortgage :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.has_parking, ad.lat, ad.lng
FROM ad
         JOIN (SELECT DISTINCT ON (ad_id) ad_id, mortgage, normal_price
               FROM price
               WHERE ad_id = ANY ($1::bigint[])
                 AND mortgage BETWEEN $2 AND $3
               ORDER BY ad_id, fetched_at DESC) latest_price ON latest_price.ad_id = ad.id
ORDER BY ad.created_at DESC
`

type FilterAdsPriceMortgageParams struct {
	AdIds    []int64 `json:"ad_ids"`
	MinPrice *int64  `json:"min_price"`
	MaxPrice *int64  `json:"max_price"`
}

// Filter ads based on list of IDs and price range (mortgage category)
func (q *Queries) FilterAdsPriceMortgage(ctx context.Context, arg FilterAdsPriceMortgageParams) ([]Ad, error) {
	rows, err := q.db.Query(ctx, filterAdsPriceMortgage, arg.AdIds, arg.MinPrice, arg.MaxPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.HasParking,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterAdsPriceRent = `-- name: FilterAdsPriceRent :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.has_parking, ad.lat, ad.lng
FROM ad
         JOIN (SELECT DISTINCT ON (ad_id) ad_id, normal_price, weekend_price
               FROM price
               WHERE ad_id = ANY ($1::bigint[])
                 AND normal_price BETWEEN $2 AND $3
               ORDER BY ad_id, fetched_at DESC) latest_price ON latest_price.ad_id = ad.id
ORDER BY ad.created_at DESC
`

type FilterAdsPriceRentParams struct {
	AdIds    []int64 `json:"ad_ids"`
	MinPrice *int64  `json:"min_price"`
	MaxPrice *int64  `json:"max_price"`
}

// Filter ads based on list of IDs and price range (rent category)
func (q *Queries) FilterAdsPriceRent(ctx context.Context, arg FilterAdsPriceRentParams) ([]Ad, error) {
	rows, err := q.db.Query(ctx, filterAdsPriceRent, arg.AdIds, arg.MinPrice, arg.MaxPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.HasParking,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdsWithoutPrice = `-- name: GetAdsWithoutPrice :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.has_parking, ad.lat, ad.lng
FROM ad
         LEFT JOIN price ON price.ad_id = ad.id
WHERE price.id IS NULL
`

// Get ads without associated price
func (q *Queries) GetAdsWithoutPrice(ctx context.Context) ([]Ad, error) {
	rows, err := q.db.Query(ctx, getAdsWithoutPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.HasParking,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPricesByAdID = `-- name: GetAllPricesByAdID :many
SELECT price.id, price.ad_id, price.fetched_at, price.has_price, price.total_price, price.price_per_meter, price.mortgage, price.normal_price, price.weekend_price
FROM price
WHERE ad_id = $1
ORDER BY fetched_at
`

// Get all prices for a specific ad by its id
func (q *Queries) GetAllPricesByAdID(ctx context.Context, id int64) ([]Price, error) {
	rows, err := q.db.Query(ctx, getAllPricesByAdID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Price
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.ID,
			&i.AdID,
			&i.FetchedAt,
			&i.HasPrice,
			&i.TotalPrice,
			&i.PricePerMeter,
			&i.Mortgage,
			&i.NormalPrice,
			&i.WeekendPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPriceByAdID = `-- name: GetLatestPriceByAdID :one
SELECT price.id, price.ad_id, price.fetched_at, price.has_price, price.total_price, price.price_per_meter, price.mortgage, price.normal_price, price.weekend_price
FROM price
WHERE ad_id = $1
ORDER BY fetched_at DESC
LIMIT 1
`

// Get the latest price for a specific ad by its id
func (q *Queries) GetLatestPriceByAdID(ctx context.Context, id int64) (Price, error) {
	row := q.db.QueryRow(ctx, getLatestPriceByAdID, id)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.AdID,
		&i.FetchedAt,
		&i.HasPrice,
		&i.TotalPrice,
		&i.PricePerMeter,
		&i.Mortgage,
		&i.NormalPrice,
		&i.WeekendPrice,
	)
	return i, err
}
