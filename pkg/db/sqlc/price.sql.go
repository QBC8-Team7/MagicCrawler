// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: price.sql

package sqlc

import (
	"context"
)

const createPrice = `-- name: CreatePrice :one
INSERT INTO price (ad_id, fetched_at, has_price, total_price, price_per_meter, mortgage, normal_price, weekend_price)
VALUES ($1,
        NOW(),
        $2,
        $3,
        $4,
        $5,
        $6,
        $7)
RETURNING id, ad_id, fetched_at, has_price, total_price, price_per_meter, mortgage, normal_price, weekend_price
`

type CreatePriceParams struct {
	AdID          int64  `json:"ad_id"`
	HasPrice      *bool  `json:"has_price"`
	TotalPrice    *int64 `json:"total_price"`
	PricePerMeter *int64 `json:"price_per_meter"`
	Mortgage      *int64 `json:"mortgage"`
	NormalPrice   *int64 `json:"normal_price"`
	WeekendPrice  *int64 `json:"weekend_price"`
}

// Insert a new price entry for a specific ad
func (q *Queries) CreatePrice(ctx context.Context, arg CreatePriceParams) (Price, error) {
	row := q.db.QueryRow(ctx, createPrice,
		arg.AdID,
		arg.HasPrice,
		arg.TotalPrice,
		arg.PricePerMeter,
		arg.Mortgage,
		arg.NormalPrice,
		arg.WeekendPrice,
	)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.AdID,
		&i.FetchedAt,
		&i.HasPrice,
		&i.TotalPrice,
		&i.PricePerMeter,
		&i.Mortgage,
		&i.NormalPrice,
		&i.WeekendPrice,
	)
	return i, err
}

const filterAdsByIdsAndMortgagePriceRange = `-- name: FilterAdsByIdsAndMortgagePriceRange :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.has_parking, ad.lat, ad.lng
FROM ad
         JOIN (SELECT DISTINCT ON (ad_id) ad_id, total_price
               FROM price
               WHERE ad_id = ANY ($1::int[])
                 AND mortgage BETWEEN $2 AND $3
               ORDER BY ad_id, fetched_at DESC) latest_price ON latest_price.ad_id = ad.id
ORDER BY ad.created_at DESC
`

type FilterAdsByIdsAndMortgagePriceRangeParams struct {
	AdIds    []int32 `json:"ad_ids"`
	MinPrice *int64  `json:"min_price"`
	MaxPrice *int64  `json:"max_price"`
}

// Filter ads based on list of IDs and price range
func (q *Queries) FilterAdsByIdsAndMortgagePriceRange(ctx context.Context, arg FilterAdsByIdsAndMortgagePriceRangeParams) ([]Ad, error) {
	rows, err := q.db.Query(ctx, filterAdsByIdsAndMortgagePriceRange, arg.AdIds, arg.MinPrice, arg.MaxPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.HasParking,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterAdsByIdsAndTotalPriceRange = `-- name: FilterAdsByIdsAndTotalPriceRange :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.has_parking, ad.lat, ad.lng
FROM ad
         JOIN (SELECT DISTINCT ON (ad_id) ad_id, total_price
               FROM price
               WHERE ad_id = ANY ($1::int[])
                 AND total_price BETWEEN $2 AND $3
               ORDER BY ad_id, fetched_at DESC) latest_price ON latest_price.ad_id = ad.id
ORDER BY ad.created_at DESC
`

type FilterAdsByIdsAndTotalPriceRangeParams struct {
	AdIds    []int32 `json:"ad_ids"`
	MinPrice *int64  `json:"min_price"`
	MaxPrice *int64  `json:"max_price"`
}

// Filter ads based on list of IDs and price range
func (q *Queries) FilterAdsByIdsAndTotalPriceRange(ctx context.Context, arg FilterAdsByIdsAndTotalPriceRangeParams) ([]Ad, error) {
	rows, err := q.db.Query(ctx, filterAdsByIdsAndTotalPriceRange, arg.AdIds, arg.MinPrice, arg.MaxPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.HasParking,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterAdsByMortgagePriceRange = `-- name: FilterAdsByMortgagePriceRange :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.has_parking, ad.lat, ad.lng
FROM ad
         JOIN (SELECT DISTINCT ON (ad_id) ad_id, mortgage
               FROM price
               WHERE mortgage >= COALESCE($1, mortgage)
                 AND mortgage <= COALESCE($2, mortgage)
               ORDER BY ad_id, fetched_at DESC) latest_price ON latest_price.ad_id = ad.id
ORDER BY ad.created_at DESC
LIMIT $4 OFFSET $3
`

type FilterAdsByMortgagePriceRangeParams struct {
	MinPrice *int64 `json:"min_price"`
	MaxPrice *int64 `json:"max_price"`
	Offset   *int32 `json:"offset"`
	Limit    *int32 `json:"limit"`
}

// Get ads with their latest mortgage price within the specified range.
// Handles cases with min_price and max_price individually or together.
func (q *Queries) FilterAdsByMortgagePriceRange(ctx context.Context, arg FilterAdsByMortgagePriceRangeParams) ([]Ad, error) {
	rows, err := q.db.Query(ctx, filterAdsByMortgagePriceRange,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.HasParking,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterAdsByTotalPriceRange = `-- name: FilterAdsByTotalPriceRange :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.has_parking, ad.lat, ad.lng
FROM ad
         JOIN (SELECT DISTINCT ON (ad_id) ad_id, total_price
               FROM price
               WHERE total_price >= COALESCE($1, total_price)
                 AND total_price <= COALESCE($2, total_price)
               ORDER BY ad_id, fetched_at DESC) latest_price ON latest_price.ad_id = ad.id
ORDER BY ad.created_at DESC
LIMIT $4 OFFSET $3
`

type FilterAdsByTotalPriceRangeParams struct {
	MinPrice *int64 `json:"min_price"`
	MaxPrice *int64 `json:"max_price"`
	Offset   *int32 `json:"offset"`
	Limit    *int32 `json:"limit"`
}

// Get ads with their latest total price within the specified range.
// Handles cases with min_price and max_price individually or together.
func (q *Queries) FilterAdsByTotalPriceRange(ctx context.Context, arg FilterAdsByTotalPriceRangeParams) ([]Ad, error) {
	rows, err := q.db.Query(ctx, filterAdsByTotalPriceRange,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.HasParking,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdsWithoutPrice = `-- name: GetAdsWithoutPrice :many
SELECT ad.id, ad.publisher_ad_key, ad.publisher_id, ad.created_at, ad.updated_at, ad.published_at, ad.category, ad.author, ad.url, ad.title, ad.description, ad.city, ad.neighborhood, ad.house_type, ad.meterage, ad.rooms_count, ad.year, ad.floor, ad.total_floors, ad.has_warehouse, ad.has_elevator, ad.has_parking, ad.lat, ad.lng
FROM ad
         LEFT JOIN price ON price.ad_id = ad.id
WHERE price.id IS NULL
`

// Get ads without associated price
func (q *Queries) GetAdsWithoutPrice(ctx context.Context) ([]Ad, error) {
	rows, err := q.db.Query(ctx, getAdsWithoutPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.PublisherAdKey,
			&i.PublisherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Category,
			&i.Author,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.City,
			&i.Neighborhood,
			&i.HouseType,
			&i.Meterage,
			&i.RoomsCount,
			&i.Year,
			&i.Floor,
			&i.TotalFloors,
			&i.HasWarehouse,
			&i.HasElevator,
			&i.HasParking,
			&i.Lat,
			&i.Lng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPricesByAdID = `-- name: GetAllPricesByAdID :many
SELECT price.id, price.ad_id, price.fetched_at, price.has_price, price.total_price, price.price_per_meter, price.mortgage, price.normal_price, price.weekend_price
FROM price
WHERE ad_id = $1
ORDER BY fetched_at
`

// Get all prices for a specific ad by its id
func (q *Queries) GetAllPricesByAdID(ctx context.Context, id int64) ([]Price, error) {
	rows, err := q.db.Query(ctx, getAllPricesByAdID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Price
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.ID,
			&i.AdID,
			&i.FetchedAt,
			&i.HasPrice,
			&i.TotalPrice,
			&i.PricePerMeter,
			&i.Mortgage,
			&i.NormalPrice,
			&i.WeekendPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPriceByAdID = `-- name: GetLatestPriceByAdID :one
SELECT price.id, price.ad_id, price.fetched_at, price.has_price, price.total_price, price.price_per_meter, price.mortgage, price.normal_price, price.weekend_price
FROM price
WHERE ad_id = $1
ORDER BY fetched_at DESC
LIMIT 1
`

// Get the latest price for a specific ad by its id
func (q *Queries) GetLatestPriceByAdID(ctx context.Context, id int64) (Price, error) {
	row := q.db.QueryRow(ctx, getLatestPriceByAdID, id)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.AdID,
		&i.FetchedAt,
		&i.HasPrice,
		&i.TotalPrice,
		&i.PricePerMeter,
		&i.Mortgage,
		&i.NormalPrice,
		&i.WeekendPrice,
	)
	return i, err
}
